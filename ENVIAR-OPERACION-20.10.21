# üìÅ M√≥dulos del sistema
import time
import signal
import getpass
from datetime import datetime, timedelta
import threading
import sys
import os
import pickle

# üìä Bibliotecas cient√≠ficas y de an√°lisis
import numpy as np
import pandas as pd

# üíπ MetaTrader 5
import MetaTrader5 as mt5

# üß† Interfaz gr√°fica (Tkinter)
import tkinter as tk
from tkinter import messagebox

# üìù Logging
import logging















# Configuraci√≥n de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
def cerrar_conexion(sig, frame):
    """Manejador de la se√±al Ctrl + C para cerrar la conexi√≥n correctamente."""
    logging.info("\nCerrando conexi√≥n con MT5...")
    mt5.shutdown()  # Cerrar MT5 de manera segura
    logging.info("Conexi√≥n cerrada.")
    exit(0)  # Salir del programa





























# Registrar el manejador de la se√±al Ctrl + C
signal.signal(signal.SIGINT, cerrar_conexion)


def connect_to_mt5():   
    """Solicita credenciales al usuario mediante GUI y establece conexi√≥n con MetaTrader 5."""
    

    resultado = {"conexion_exitosa": False}  # variable mutable para comunicar resultado

    # ======= Crear ventana ra√≠z oculta ======= #
    root = tk.Tk()
    root.withdraw()  # Oculta la ventana principal para evitar que aparezca la ventana blanca

    # ======= Crear Toplevel maximizado ======= #
    ventana = tk.Toplevel()
    ventana.title("DEEPTRADE")
    ventana.configure(bg="#ffffff")
    ventana.state("zoomed")  # Maximizamos la ventana al iniciar
    ventana.grab_set()       # Modal
    ventana.focus_force()    # Forzamos el foco
    ventana.update()         # Asegura que se renderice antes de colocar los elementos

    def iniciar_conexion(event=None):
        try:
            cuenta = int(entry_cuenta.get())
            servidor = entry_servidor.get()
            contrase√±a = entry_password.get()
        except ValueError:
            logging.error("El n√∫mero de cuenta debe ser un n√∫mero entero.")
            messagebox.showerror("Error", "El n√∫mero de cuenta debe ser un n√∫mero entero.")
            return

        if not mt5.initialize():
            logging.error("Error al inicializar MT5: %s", mt5.last_error())
            messagebox.showerror("Error", f"Error al inicializar MT5: {mt5.last_error()}")
            return

        if not mt5.login(cuenta, password=contrase√±a, server=servidor):
            logging.error("Error al iniciar sesi√≥n: %s", mt5.last_error())
            mt5.shutdown()
            messagebox.showerror("Error", f"Error al iniciar sesi√≥n: {mt5.last_error()}")
            return

        logging.info("Conexi√≥n exitosa a MT5.")
        resultado["conexion_exitosa"] = True
        messagebox.showinfo("√âxito", "Conexi√≥n exitosa a MT5.")  # Espera confirmaci√≥n del usuario
        ventana.destroy()

    def agregar_menu_contextual(widget):
        menu = tk.Menu(widget, tearoff=0)
        menu.add_command(label="Copiar", command=lambda: widget.event_generate("<<Copy>>"))
        menu.add_command(label="Pegar", command=lambda: widget.event_generate("<<Paste>>"))

        def mostrar_menu(event):
            menu.tk_popup(event.x_root, event.y_root)
        widget.bind("<Button-3>", mostrar_menu)

    contenedor = tk.Frame(ventana, bg="#ffffff")
    contenedor.place(relx=0.5, rely=0.5, anchor="center")

    tk.Label(contenedor, text="DEEPTRADE", font=("Arial", 20, "bold"), bg="#ffffff", fg="#004c99").pack(pady=(10, 30))

    global entry_cuenta
    tk.Label(contenedor, text="N√∫mero de cuenta", font=("Arial", 12), bg="#ffffff", fg="#000000").pack()
    entry_cuenta = tk.Entry(contenedor, width=40, font=("Arial", 12), relief="solid", bd=1, bg="#f0f0f0", fg="#000000")
    entry_cuenta.pack(pady=(0, 15), ipady=5)
    agregar_menu_contextual(entry_cuenta)

    global entry_servidor
    tk.Label(contenedor, text="Servidor", font=("Arial", 12), bg="#ffffff", fg="#000000").pack()
    entry_servidor = tk.Entry(contenedor, width=40, font=("Arial", 12), relief="solid", bd=1, bg="#f0f0f0", fg="#000000")
    entry_servidor.pack(pady=(0, 15), ipady=5)
    agregar_menu_contextual(entry_servidor)

    global entry_password
    tk.Label(contenedor, text="Contrase√±a", font=("Arial", 12), bg="#ffffff", fg="#000000").pack()

    frame_password = tk.Frame(contenedor, bg="#ffffff")
    frame_password.pack(pady=(0, 25))

    entry_password = tk.Entry(frame_password, show="*", width=34, font=("Arial", 12),
                              relief="solid", bd=1, bg="#f0f0f0", fg="#000000")
    entry_password.pack(side="left", ipady=5)
    agregar_menu_contextual(entry_password)

    def toggle_password():
        if entry_password.cget("show") == "":
            entry_password.config(show="*")
            btn_ver.config(text="üëÅ")
        else:
            entry_password.config(show="")
            btn_ver.config(text="üëÅ")

    btn_ver = tk.Button(frame_password, text="üëÅ", font=("Arial", 10),
                        bg="#ffffff", fg="#666666", bd=0,
                        command=toggle_password, cursor="hand2",
                        activebackground="#f0f0f0", activeforeground="#000000")
    btn_ver.pack(side="left", padx=(5, 0))

    # ======= VINCULAR ENTER A TODAS LAS ENTRADAS Y NO SOLO CONTRASE√ëA ======= #
    entry_cuenta.bind("<Return>", iniciar_conexion)
    entry_servidor.bind("<Return>", iniciar_conexion)
    entry_password.bind("<Return>", iniciar_conexion)

    # ======= BOT√ìN DE CONEXI√ìN (NO SE TOCA SU L√ìGICA) ======= #
    btn_conectar = tk.Button(
        contenedor,
        text="Conectar",
        command=iniciar_conexion,
        bg="#28a745",
        fg="#ffffff",
        activebackground="#1c7c3a",
        activeforeground="#ffffff",
        padx=20,
        pady=10,
        font=("Arial", 11, "bold"),
        relief="flat",
        cursor="hand2"
    )
    btn_conectar.pack()

    def on_enter(e):
        btn_conectar.config(bg="#1c7c3a")

    def on_leave(e):
        btn_conectar.config(bg="#28a745")

    btn_conectar.bind("<Enter>", on_enter)
    btn_conectar.bind("<Leave>", on_leave)

    ventana.wait_window()
    return resultado["conexion_exitosa"]





































logging.basicConfig(level=logging.ERROR)


def get_account_equity():
    """
    Obtiene el balance y el margen libre de la cuenta.
    """
    account_info = mt5.account_info()
    if account_info is None:
        print("No se pudo obtener la informaci√≥n de la cuenta.")
        return None

    balance = account_info.balance
    free_margin = account_info.margin_free

    print(f"Balance: {balance}, Margen libre: {free_margin}")
    return balance, free_margin


def mostrar_equity_gui(parent=None):
    """
    Muestra una ventana Toplevel con el balance y margen libre.
    Devuelve True si se presiona "DISTRIBUIR".
    """
    resultado = {"continuar": False}

    # Si no se pasa parent, crear ventana ra√≠z oculta
    if parent is None:
        parent = tk.Tk()
        parent.withdraw()

    # Crear ventana secundaria
    ventana_equity = tk.Toplevel(parent)
    ventana_equity.title("üíº DEEPTRADE - Equity de la Cuenta")
    ventana_equity.state("zoomed")  # MAXIMIZAR VENTANA
    ventana_equity.configure(bg="#ffffff")  # Fondo blanco

    # Frame contenedor central
    contenedor = tk.Frame(ventana_equity, bg="#ffffff")
    contenedor.place(relx=0.5, rely=0.5, anchor="center")

    # T√≠tulo con emoji üìä en color gris oscuro
    label_titulo = tk.Label(
        contenedor,
        text="üìä Informaci√≥n de la cuenta MT5",
        font=("Helvetica", 18, "bold"),
        bg="#ffffff",
        fg="#333333"
    )
    label_titulo.pack(pady=10)

    # Etiquetas balance y margen
    tk.Label(contenedor, text="Balance:", font=("Helvetica", 14), bg="#ffffff", fg="#000000").pack()
    balance_label = tk.Label(contenedor, text="$0.00", font=("Helvetica", 16, "bold"), fg="#0000ff", bg="#ffffff")
    balance_label.pack(pady=5)

    tk.Label(contenedor, text="Margen libre disponible:", font=("Helvetica", 14), bg="#ffffff", fg="#000000").pack()
    margen_label = tk.Label(contenedor, text="$0.00", font=("Helvetica", 16, "bold"), fg="#008000", bg="#ffffff")
    margen_label.pack(pady=5)

    # Funci√≥n para actualizar valores
    def actualizar():
        equity = get_account_equity()
        if equity:
            balance, free_margin = equity
            balance_label.config(text=f"${balance:,.2f}")
            margen_label.config(text=f"${free_margin:,.2f}")
        else:
            messagebox.showerror("Error", "No se pudo obtener la informaci√≥n de la cuenta MT5.")

    # Funci√≥n cuando se presiona DISTRIBUIR
    def distribuir_capital():
        equity = get_account_equity()
        if equity:
            _, free_margin = equity
            capital_x_symbol = {
                "XAUUSD": free_margin * 0.33,
                "BTCUSD": free_margin * 0.33,
                "EURUSD": free_margin * 0.34
            }
            for symbol, amount in capital_x_symbol.items():
                print(f"{symbol}: ${amount:,.2f}")
            resultado["continuar"] = True
            ventana_equity.destroy()
        else:
            messagebox.showerror("Error", "No se pudo calcular la distribuci√≥n.")

    # Bot√≥n de actualizar
    btn_actualizar = tk.Button(
        contenedor,
        text="üîÑ Actualizar Equity",
        bg="#007acc",
        fg="#ffffff",
        activebackground="#005f99",
        activeforeground="#ffffff",
        font=("Helvetica", 12, "bold"),
        padx=20,
        pady=10,
        relief="flat",
        cursor="hand2",
        command=actualizar
    )
    btn_actualizar.pack(pady=10)
    btn_actualizar.bind("<Enter>", lambda e: btn_actualizar.config(bg="#005f99"))
    btn_actualizar.bind("<Leave>", lambda e: btn_actualizar.config(bg="#007acc"))

    # Bot√≥n de distribuir
    btn_distribuir = tk.Button(
        contenedor,
        text="üì§ DISTRIBUIR",
        bg="#28a745",
        fg="#ffffff",
        activebackground="#1e7e34",
        activeforeground="#ffffff",
        font=("Helvetica", 14, "bold"),
        padx=20,
        pady=10,
        relief="flat",
        cursor="hand2",
        command=distribuir_capital
    )
    btn_distribuir.pack(pady=10)
    btn_distribuir.bind("<Enter>", lambda e: btn_distribuir.config(bg="#1e7e34"))
    btn_distribuir.bind("<Leave>", lambda e: btn_distribuir.config(bg="#28a745"))

    # Inicializa con datos reales
    actualizar()

    # Esperar a que se cierre la ventana antes de retornar
    ventana_equity.grab_set()
    ventana_equity.wait_window()

    return resultado["continuar"]






































def calculate_risk_and_capital_distribution(symbols, free_margin):  
    """
    Calcula el riesgo y distribuye el capital basado en el margen libre y el porcentaje definido por el usuario.

    Args:
        symbols (list): Lista de s√≠mbolos financieros.
        free_margin (float): Margen libre de la cuenta.

    Returns:
        dict: Un diccionario con la distribuci√≥n de capital para cada s√≠mbolo, o None si se cancela.
    """
    if free_margin is None or free_margin <= 0:
        logging.error("El margen libre no es v√°lido o es insuficiente.")
        return None

    # ‚úÖ Lista fija de pares que se usar√°n dentro de la ventana
    symbols = [
        "GBPJPYm", "GBPUSDm", "USDZARm", "GBPNZDm", "GBPAUDm",
        "EURZARm", "AUDUSDm", "NZDJPYm", "AUDJPYm", "GBPCADm"
    ]

    def mostrar_distribucion_gui():
        ventana = tk.Toplevel()
        ventana.title("üìä Distribuci√≥n de Capital")
        ventana.configure(bg="white")
        ventana.state("zoomed")  # ‚úÖ Maximizar ventana

        # ‚úÖ Captura de cierre con X
        def confirmar_salida():
            if messagebox.askokcancel("SALIR DEL PROGRAMA", "¬øDesea cerrar el programa?"):
                ventana.destroy()
                sys.exit()

        ventana.protocol("WM_DELETE_WINDOW", confirmar_salida)

        contenedor_central = tk.Frame(ventana, bg="white")
        contenedor_central.place(relx=0.5, rely=0.5, anchor="center")  # ‚úÖ Centrado total

        tk.Label(contenedor_central, text="ASIGNAR % DEL MARGEN LIBRE", 
                 font=("Segoe UI", 18, "bold"), fg="black", bg="white").pack(pady=(10, 10))

        porcentaje_var = tk.IntVar(value=0)

        def aumentar():
            if porcentaje_var.get() < 100:
                porcentaje_var.set(porcentaje_var.get() + 1)

        def disminuir():
            if porcentaje_var.get() > 0:
                porcentaje_var.set(porcentaje_var.get() - 1)

        botones_frame = tk.Frame(contenedor_central, bg="white")
        botones_frame.pack(pady=5)

        def ripple_effect(button, color="#444444", duration=100):
            original = button.cget("bg")
            button.configure(bg=color)
            button.after(duration, lambda: button.configure(bg=original))

        btn_menos = tk.Button(botones_frame, text="‚Äì", command=lambda: [ripple_effect(btn_menos), disminuir()],
                              font=("Segoe UI", 14, "bold"), bg="white", fg="#111111",
                              activebackground="white", activeforeground="black",
                              width=3, relief="flat", cursor="hand2")
        btn_menos.pack(side="left", padx=10)

        label_porcentaje = tk.Label(botones_frame, textvariable=porcentaje_var,
                                    font=("Segoe UI", 14, "bold"), bg="white", width=5)
        label_porcentaje.pack(side="left")

        btn_mas = tk.Button(botones_frame, text="+", command=lambda: [ripple_effect(btn_mas), aumentar()],
                            font=("Segoe UI", 14, "bold"), bg="white", fg="#111111",
                            activebackground="white", activeforeground="black",
                            width=3, relief="flat", cursor="hand2")
        btn_mas.pack(side="left", padx=10)

        resultado_frame = tk.Frame(contenedor_central, bg="white")
        resultado_frame.pack(pady=15)

        ventana.capital_distribution = None
        ventana.resultado_final = False

        def confirmar():
            for widget in resultado_frame.winfo_children():
                widget.destroy()

            risk_percentage = porcentaje_var.get()
            if not 0 <= risk_percentage <= 100:
                logging.error("El porcentaje debe estar entre 0 y 100.")
                messagebox.showerror("Error", "El porcentaje debe estar entre 0 y 100.")
                return

            number_of_symbols = len(symbols)
            if number_of_symbols == 0:
                logging.error("La lista de s√≠mbolos est√° vac√≠a.")
                messagebox.showerror("Error", "La lista de s√≠mbolos est√° vac√≠a.")
                return

            capital_per_symbol = (free_margin * risk_percentage / 100) / number_of_symbols
            logging.info(f"El capital asignado a cada s√≠mbolo ser√°: {capital_per_symbol:.2f}")

            capital_distribution = {symbol: capital_per_symbol for symbol in symbols}

            fila = 0
            columna = 0
            for symbol in symbols:
                capital = capital_distribution[symbol]
                entry = tk.Entry(resultado_frame, width=25, font=("Segoe UI", 10), justify="center",
                                 relief="solid", bg="#f4f4f4")
                entry.insert(0, f"{symbol}: ${capital:.2f}")
                entry.config(state="readonly")
                entry.grid(row=fila, column=columna, padx=5, pady=5)

                columna += 1
                if columna >= 2:
                    columna = 0
                    fila += 1

            ventana.capital_distribution = capital_distribution
            btn_confirmar.pack_forget()  # ‚úÖ Ocultar bot√≥n ACEPTAR despu√©s de usar
            btn_continuar.pack(pady=(20, 10))  # ‚úÖ Mostrar bot√≥n CONTINUAR

        btn_confirmar = tk.Button(contenedor_central, text="ACEPTAR", 
                                  command=lambda: [ripple_effect(btn_confirmar, "#222222"), confirmar()],
                                  bg="white", fg="#111111",
                                  activebackground="white", activeforeground="black",
                                  font=("Segoe UI", 11, "bold"), padx=20, pady=5,
                                  relief="flat", cursor="hand2")
        btn_confirmar.pack(pady=(20, 0))

        def continuar():
            ripple_effect(btn_continuar, "#222222")
            ventana.resultado_final = True
            ventana.destroy()

        btn_continuar = tk.Button(contenedor_central, text="CONTINUAR", bg="white", fg="#111111",
                                  activebackground="white", activeforeground="black",
                                  font=("Segoe UI", 11, "bold"), padx=20, pady=5,
                                  relief="flat", cursor="hand2",
                                  command=continuar)
        btn_continuar.pack_forget()

        ventana.wait_window()
        return ventana.resultado_final

    resultado = mostrar_distribucion_gui()
    if resultado:
        return True
    else:
        return None




























# Configurar logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")
def calcular_atr(simbolo, timeframe=mt5.TIMEFRAME_M1, periodos=14):
    """
    Calcula el Average True Range (ATR) para un s√≠mbolo dado.

    Par√°metros:
    - simbolo (str): S√≠mbolo del activo en MT5.
    - timeframe (int): Timeframe de los datos (por defecto M1).
    - periodos (int): N√∫mero de per√≠odos para calcular el ATR.

    Retorna:
    - float: Valor del ATR.
    """
    try:
        rates = mt5.copy_rates_from_pos(simbolo, timeframe, 0, periodos + 1)
        if rates is None or len(rates) < periodos + 1:
            raise ValueError(f"No se pudieron obtener suficientes datos para ATR ({simbolo})")

        df = pd.DataFrame(rates)
        df["high-low"] = df["high"] - df["low"]
        df["high-close"] = abs(df["high"] - df["close"].shift(1))
        df["low-close"] = abs(df["low"] - df["close"].shift(1))

        df["true_range"] = df[["high-low", "high-close", "low-close"]].max(axis=1)
        atr = df["true_range"].rolling(window=periodos).mean().iloc[-1]

        return atr

    except Exception as e:
        logging.error(f"‚ùå Error al calcular ATR para {simbolo}: {str(e)}")
        return None

def calcular_tp(precio_actual, simbolo, timeframe):
    """
    Calcula el Take Profit (TP) din√°micamente usando el ATR del s√≠mbolo en el timeframe dado.
    """
    atr = calcular_atr(simbolo, timeframe)  # Obtener la volatilidad media del mercado
    tp = precio_actual + (atr * 0.5)  # TP ajustado a la mitad del ATR
    return tp


































import locale 
# ‚ö° Buffer para almacenar errores pasados
error_memoria = []
# Establecer el sistema decimal americano
locale.setlocale(locale.LC_NUMERIC, 'en_US.UTF-8')
def execute_trade_multiple(direcciones_trade, capital_assigned, risk_per_trade, modelo, modelo_path):  
    from datetime import datetime, timedelta
    import pytz
    import os
    import locale
    import logging
    import MetaTrader5 as mt5
    import numpy as np
    from time import sleep, time
    import random
    import threading
    import uuid

    locale.setlocale(locale.LC_ALL, 'C')

    if not isinstance(direcciones_trade, dict):
        raise ValueError("‚ùå El par√°metro 'direcciones_trade' debe ser un diccionario.")

    if not modelo_path or not os.path.exists(modelo_path):
        logging.warning("üî∫ La ruta del modelo no es v√°lida o no existe. Verifica el par√°metro 'modelo_path'.")
        return

    if not mt5.initialize():
        logging.error("‚ùå No se pudo inicializar MetaTrader 5.")
        return

    def enviar_orden_robusta(request, reintentos=3, pausa=0.5):
        for intento in range(reintentos):
            result = mt5.order_send(request)
            if result is not None:
                return result
            logging.warning(f"‚ö†Ô∏è Reintentando env√≠o de orden (intento {intento+1}/{reintentos})...")
            sleep(pausa)
        return None

    def enviar_y_cerrar_operacion(simbolo, direccion, precio_operacion, lot_size, i):
        try:
            action_type = mt5.ORDER_TYPE_BUY if direccion == "üìà SUBE" else mt5.ORDER_TYPE_SELL
            sleep(random.uniform(0.15, 0.25))  # üßç Delay previo simulando humano
            comentario_unico = f"Scalp{i}_{int(time())}"  # Seguro y corto (<32 caracteres)

            logging.info(f"üõí [{i+1}/10] Enviando orden {direccion} en {simbolo} a {precio_operacion}")
            result = enviar_orden_robusta({
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": simbolo,
                "volume": lot_size,
                "type": action_type,
                "price": precio_operacion,
                "tp": 0.0,
                "deviation": 0,
                "magic": 123456,
                "comment": comentario_unico
            })

            if result is None:
                logging.error(f"‚ùå No se recibi√≥ respuesta de MT5 en orden {i+1} de {simbolo}. Posible desconexi√≥n o s√≠mbolo inactivo.")
                return

            if result.retcode != mt5.TRADE_RETCODE_DONE:
                logging.warning(f"‚ö†Ô∏è Fallo orden {i+1} en {simbolo}: C√≥digo {result.retcode}")
                return

            ticket = result.order
            precio_ejecutado = result.price
            logging.info(f"‚úÖ Orden {i+1} ejecutada en {simbolo} con ticket {ticket} | Precio ejecutado: {precio_ejecutado:.5f}")

            sleep(random.uniform(0.1, 0.2))  # Esperar antes de modificar TP

            distancia_tp = round(random.uniform(0.098, 0.102), 5)
            tp_final = precio_ejecutado + distancia_tp if direccion == "üìà SUBE" else precio_ejecutado - distancia_tp

            if (direccion == "üìà SUBE" and tp_final <= precio_ejecutado) or \
               (direccion == "üìâ BAJA" and tp_final >= precio_ejecutado):
                logging.error(f"‚ùå TP incoherente detectado en {simbolo}. Corrigiendo...")
                tp_final = precio_ejecutado + abs(distancia_tp) if direccion == "üìà SUBE" else precio_ejecutado - abs(distancia_tp)

            modify_result = mt5.order_send({
                "action": mt5.TRADE_ACTION_SLTP,
                "position": ticket,
                "sl": 0.0,
                "tp": tp_final,
                "symbol": simbolo,
                "magic": 123456,
                "comment": "Ajuste TP post ejecuci√≥n"
            })

            if modify_result is None or modify_result.retcode != mt5.TRADE_RETCODE_DONE:
                logging.error(f"‚ùå No se pudo modificar TP en {simbolo}.")
            else:
                logging.info(f"üõ†Ô∏è TP ajustado correctamente en {simbolo} a {tp_final:.5f} | ticket {ticket}")

            tiempo_inicio = time()
            cerrada = False

            while time() - tiempo_inicio < 60:
                posiciones = mt5.positions_get(ticket=ticket)
                if posiciones:
                    tiempo_transcurrido = time() - tiempo_inicio
                    if tiempo_transcurrido < 4.5:
                        sleep(4.5 - tiempo_transcurrido)
                    profit = posiciones[0].profit
                    if profit >= 0.10:
                        cierre_tipo = mt5.ORDER_TYPE_SELL if action_type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
                        cierre = mt5.order_send({
                            "action": mt5.TRADE_ACTION_DEAL,
                            "symbol": simbolo,
                            "volume": lot_size,
                            "type": cierre_tipo,
                            "position": posiciones[0].ticket,
                            "price": mt5.symbol_info_tick(simbolo).bid if cierre_tipo == mt5.ORDER_TYPE_SELL else mt5.symbol_info_tick(simbolo).ask,
                            "deviation": 0,
                            "magic": 123456,
                            "comment": "Cierre autom√°tico +0.10"
                        })
                        if cierre and cierre.retcode == mt5.TRADE_RETCODE_DONE:
                            tiempo_abierto = time() - tiempo_inicio
                            logging.info(f"üí∞ Cierre anticipado por ganancia >= +0.10 USD en {simbolo}. Ticket: {ticket} | Ganancia: {profit:.2f} USD | Tiempo abierto: {tiempo_abierto:.0f} segundos")
                        cerrada = True
                        break
                else:
                    historial = mt5.history_deals_get(datetime.now() - timedelta(minutes=5), datetime.now())
                    if historial:
                        cierres = [h for h in historial if h.position_id == ticket]
                        if cierres:
                            ultimo_cierre = cierres[-1]
                            tiempo_abierto = time() - tiempo_inicio
                            if ultimo_cierre.profit < 0:
                                logging.info(f"üò° Cierre interno detectado por p√©rdida <= 0.00 USD en {simbolo}. | Ticket: {ticket} | P√©rdida: {ultimo_cierre.profit:.2f} USD | Tiempo abierto: {tiempo_abierto:.0f} segundos")
                            else:
                                logging.info(f"üö´ Cierre externo detectado por perdida <= 0.00 USD en {simbolo}. | Ticket: {ticket} | perdida : {ultimo_cierre.profit:.2f} USD | Tiempo abierto: {tiempo_abierto:.0f} segundos")
                    cerrada = True
                    break

                sleep(0.5)

            if not cerrada:
                posiciones = mt5.positions_get(ticket=ticket)
                if posiciones:
                    profit_final = posiciones[0].profit
                    cierre_tipo = mt5.ORDER_TYPE_SELL if action_type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
                    cierre = mt5.order_send({
                        "action": mt5.TRADE_ACTION_DEAL,
                        "symbol": simbolo,
                        "volume": lot_size,
                        "type": cierre_tipo,
                        "position": posiciones[0].ticket,
                        "price": mt5.symbol_info_tick(simbolo).bid if cierre_tipo == mt5.ORDER_TYPE_SELL else mt5.symbol_info_tick(simbolo).ask,
                        "deviation": 0,
                        "magic": 123456,
                        "comment": "Cierre autom√°tico 60s"
                    })
                    if cierre and cierre.retcode == mt5.TRADE_RETCODE_DONE:
                        tiempo_abierto = time() - tiempo_inicio
                        logging.info(f"üïí Operaci√≥n cerrada despu√©s de 60s en {simbolo}|Ticket: {ticket} | P√©rdida: {profit_final:.2f} USD")
        except Exception as e:
            logging.error(f"‚ùå Excepci√≥n en operaci√≥n {i+1} de {simbolo}: {e}")

    def procesar_simbolo(simbolo, trade_data):
        try:
            direccion_base, _ = trade_data[0], trade_data[1]
            operaciones = []
            for i in range(10):
                direccion = direccion_base
                symbol_info = mt5.symbol_info(simbolo)
                tick = mt5.symbol_info_tick(simbolo)
                if not symbol_info or not tick:
                    logging.warning(f"‚ùå No se pudo obtener info de {simbolo}.")
                    return
                mt5.symbol_select(simbolo, True)
                spread = tick.ask - tick.bid
                precio_actual = tick.ask if direccion == "üìà SUBE" else tick.bid
                variacion = random.uniform(-spread / 10, spread / 10)
                precio_operacion = round(precio_actual + variacion, symbol_info.digits)
                symbol_capital = capital_assigned.get(simbolo, 0)
                risk_amount = symbol_capital * (risk_per_trade / 100)
                lot_size = risk_amount / precio_operacion
                lot_size = max(symbol_info.volume_min,
                               min(round(lot_size / symbol_info.volume_step) * symbol_info.volume_step, symbol_info.volume_max))
                hilo_op = threading.Thread(
                    target=enviar_y_cerrar_operacion,
                    args=(simbolo, direccion, precio_operacion, lot_size, i)
                )
                operaciones.append(hilo_op)
                hilo_op.start()
                sleep(random.uniform(0.15, 0.35))  # Desfase entre hilos

            for op in operaciones:
                op.join()

        except Exception as e:
            logging.error(f"‚ùå Excepci√≥n en {simbolo}: {e}")

    for simbolo, datos in direcciones_trade.items():
        procesar_simbolo(simbolo, datos)
        print("\n" * 10 + "=" * 120)






   
